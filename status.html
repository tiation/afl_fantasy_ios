<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèÜ AFL Fantasy Platform - Status Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-cyan: #00ffff;
            --neon-green: #00ff41;
            --neon-orange: #ff8c00;
            --neon-red: #ff0040;
            --neon-purple: #b000ff;
            --dark-bg: #000000;
            --dark-card: #0a0a0a;
            --dark-border: #1a1a1a;
            --text-primary: #ffffff;
            --text-secondary: #b0b0b0;
            --text-accent: var(--neon-cyan);
            --shadow-neon: 0 0 20px rgba(0, 255, 255, 0.5);
            --shadow-strong: 0 0 40px rgba(0, 255, 255, 0.3);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--dark-bg);
            background-attachment: fixed;
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            overflow-x: hidden;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at 20% 80%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(0, 255, 65, 0.08) 0%, transparent 50%),
                        radial-gradient(circle at 40% 40%, rgba(176, 0, 255, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: var(--dark-card);
            border-radius: 20px;
            border: 2px solid var(--neon-cyan);
            box-shadow: var(--shadow-neon);
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(0, 255, 255, 0.2), transparent);
            animation: rotate 6s linear infinite;
            z-index: -1;
        }
        
        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .header h1 {
            font-size: 2.8em;
            font-weight: 700;
            margin-bottom: 12px;
            color: var(--neon-cyan);
            text-shadow: 0 0 20px var(--neon-cyan);
        }
        
        .header p {
            font-size: 1.1em;
            font-weight: 500;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .status-card {
            background: var(--dark-card);
            border-radius: 20px;
            padding: 30px;
            border: 1px solid var(--dark-border);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .status-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }
        
        .status-card:hover::before {
            left: 100%;
        }
        
        .status-card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: var(--shadow-neon);
            border-color: var(--neon-green);
        }
        
        .status-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .status-icon {
            font-size: 2em;
            margin-right: 15px;
        }
        
        .status-title {
            font-size: 1.4em;
            font-weight: 600;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        
        .status-healthy { background: #10B981; }
        .status-warning { background: #F59E0B; }
        .status-error { background: #EF4444; }
        .status-loading { background: #6B7280; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-details {
            margin-top: 10px;
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }
        
        .actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 30px;
        }
        
        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.95em;
            text-decoration: none;
            color: white;
            background: var(--dark-card);
            border: 1px solid var(--dark-border);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.1);
            transition: all 0.3s ease;
            transform: translate(-50%, -50%);
        }
        
        .btn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .btn:hover {
            background: var(--dark-card);
            transform: translateY(-3px) scale(1.05);
            box-shadow: var(--shadow-neon);
            border-color: var(--neon-cyan);
        }
        
        .btn-primary {
            background: var(--dark-card);
            border: 2px solid var(--neon-cyan);
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        
        .btn-primary:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 30px var(--neon-cyan);
        }
        
        .btn-secondary {
            background: var(--dark-card);
            border: 2px solid var(--neon-green);
            color: var(--neon-green);
            text-shadow: 0 0 10px var(--neon-green);
        }
        
        .btn-secondary:hover {
            background: rgba(0, 255, 65, 0.1);
            box-shadow: 0 0 30px var(--neon-green);
        }
        
        .logs {
            background: var(--glass-bg);
            border-radius: 16px;
            padding: 25px;
            margin-top: 30px;
            font-family: 'Monaco', 'SF Mono', 'Consolas', monospace;
            font-size: 0.85em;
            max-height: 350px;
            overflow-y: auto;
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-soft);
            transition: all 0.3s ease;
        }
        
        .logs:hover {
            box-shadow: var(--shadow-medium);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-radius: 3px;
        }
        
        .log-info { color: #60A5FA; }
        .log-success { color: #10B981; }
        .log-warning { color: #F59E0B; }
        .log-error { color: #EF4444; }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .refresh-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            display: none;
        }
        
        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 350px;
        }
        
        .toast {
            background: var(--dark-card);
            border: 1px solid var(--dark-border);
            border-radius: 12px;
            padding: 16px 20px;
            margin-bottom: 10px;
            transform: translateX(400px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .toast.show {
            transform: translateX(0);
        }
        
        .toast.success {
            border-color: var(--neon-green);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.2);
        }
        
        .toast.error {
            border-color: var(--neon-red);
            box-shadow: 0 0 20px rgba(255, 0, 64, 0.2);
        }
        
        .toast.warning {
            border-color: var(--neon-orange);
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.2);
        }
        
        .toast.info {
            border-color: var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
        }
        
        .toast-icon {
            font-size: 1.2em;
            flex-shrink: 0;
        }
        
        .toast-message {
            flex: 1;
            font-size: 0.9em;
        }
        
        .toast-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2em;
            padding: 0;
            margin-left: 10px;
        }
        
        /* Performance Metrics Panel */
        .metrics-panel {
            background: var(--dark-card);
            border-radius: 16px;
            padding: 25px;
            margin-top: 20px;
            border: 1px solid var(--dark-border);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.1);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            border: 1px solid var(--dark-border);
        }
        
        .metric-value {
            font-size: 1.8em;
            font-weight: 700;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
        }
        
        .metric-label {
            font-size: 0.9em;
            color: var(--text-secondary);
            margin-top: 5px;
        }
        
        /* Search and Filter for Logs */
        .log-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .log-search {
            flex: 1;
            min-width: 200px;
            background: var(--dark-card);
            border: 1px solid var(--dark-border);
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 0.9em;
        }
        
        .log-filter {
            background: var(--dark-card);
            border: 1px solid var(--dark-border);
            border-radius: 8px;
            padding: 8px 12px;
            color: var(--text-primary);
            font-size: 0.9em;
        }
        
        .log-entry.hidden {
            display: none;
        }
        
        /* Service Control Buttons */
        .service-controls {
            margin-top: 15px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .service-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 0.8em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-primary);
            border: 1px solid var(--dark-border);
        }
        
        .service-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
            border-color: var(--neon-cyan);
        }
        
        .service-btn.start {
            background: rgba(0, 255, 65, 0.1);
            border-color: var(--neon-green);
            color: var(--neon-green);
        }
        
        .service-btn.stop {
            background: rgba(255, 0, 64, 0.1);
            border-color: var(--neon-red);
            color: var(--neon-red);
        }
        
        .service-btn.restart {
            background: rgba(255, 140, 0, 0.1);
            border-color: var(--neon-orange);
            color: var(--neon-orange);
        }
        
        .service-btn.fix {
            background: rgba(0, 255, 255, 0.1);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
        }
        
        .service-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Error Messages */
        .error-message {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(255, 0, 64, 0.1);
            border: 1px solid var(--neon-red);
            border-radius: 6px;
            font-size: 0.85em;
            color: var(--neon-red);
        }
        
        .warning-message {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(255, 140, 0, 0.1);
            border: 1px solid var(--neon-orange);
            border-radius: 6px;
            font-size: 0.85em;
            color: var(--neon-orange);
        }
        
        .info-message {
            margin-top: 10px;
            padding: 8px 12px;
            background: rgba(0, 255, 255, 0.1);
            border: 1px solid var(--neon-cyan);
            border-radius: 6px;
            font-size: 0.85em;
            color: var(--neon-cyan);
        }
        
        /* Loading Spinner for Buttons */
        .btn-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: currentColor;
            animation: spin 1s linear infinite;
            margin-right: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üèÜ AFL Fantasy Intelligence Platform</h1>
            <p>Real-time Status Dashboard</p>
        </div>
        
        <div class="status-grid">
            <div class="status-card">
                <div class="status-header">
                    <div class="status-icon">üåê</div>
                    <div class="status-title">React Frontend</div>
                </div>
                <div class="status-details" id="web-status">
                    <div class="metric">
                        <span>Status:</span>
                        <span id="web-status-indicator"><div class="status-indicator status-loading"></div>Checking...</span>
                    </div>
                    <div class="metric">
                        <span>Build:</span>
                        <span id="web-build">Production</span>
                    </div>
                    <div class="metric">
                        <span>Bundle Size:</span>
                        <span id="web-bundle-size">Loading...</span>
                    </div>
                </div>
                <div class="service-controls">
                    <button class="service-btn start" onclick="startService('web')" id="web-start-btn">‚ñ∂Ô∏è Start</button>
                    <button class="service-btn stop" onclick="stopService('web')" id="web-stop-btn">‚èπÔ∏è Stop</button>
                    <button class="service-btn restart" onclick="restartService('web')" id="web-restart-btn">üîÑ Restart</button>
                    <button class="service-btn fix" onclick="quickFix('web')" id="web-fix-btn">üîß Quick Fix</button>
                </div>
                <div id="web-error-message" class="error-message" style="display: none;"></div>
            </div>
            
            <div class="status-card">
                <div class="status-header">
                    <div class="status-icon">üîå</div>
                    <div class="status-title">API Server</div>
                </div>
                <div class="status-details" id="api-status">
                    <div class="metric">
                        <span>Status:</span>
                        <span id="api-status-indicator"><div class="status-indicator status-loading"></div>Checking...</span>
                    </div>
                    <div class="metric">
                        <span>Health:</span>
                        <span id="api-health">Checking...</span>
                    </div>
                    <div class="metric">
                        <span>Uptime:</span>
                        <span id="api-uptime">-</span>
                    </div>
                </div>
                <div class="service-controls">
                    <button class="service-btn start" onclick="startService('api')" id="api-start-btn">‚ñ∂Ô∏è Start</button>
                    <button class="service-btn stop" onclick="stopService('api')" id="api-stop-btn">‚èπÔ∏è Stop</button>
                    <button class="service-btn restart" onclick="restartService('api')" id="api-restart-btn">üîÑ Restart</button>
                    <button class="service-btn fix" onclick="quickFix('api')" id="api-fix-btn">üîß Quick Fix</button>
                </div>
                <div id="api-error-message" class="error-message" style="display: none;"></div>
            </div>
            
            <div class="status-card">
                <div class="status-header">
                    <div class="status-icon">üêç</div>
                    <div class="status-title">Python Scrapers</div>
                </div>
                <div class="status-details" id="scraper-status">
                    <div class="metric">
                        <span>Status:</span>
                        <span id="scraper-status-indicator"><div class="status-indicator status-loading"></div>Checking...</span>
                    </div>
                    <div class="metric">
                        <span>Last Scrape:</span>
                        <span id="scraper-last-run">Loading...</span>
                    </div>
                    <div class="metric">
                        <span>Players Synced:</span>
                        <span id="scraper-players">Loading...</span>
                    </div>
                </div>
            </div>
            
            <div class="status-card">
                <div class="status-header">
                    <div class="status-icon">üì±</div>
                    <div class="status-title">iOS Application</div>
                </div>
                <div class="status-details" id="ios-status">
                    <div class="metric">
                        <span>Sync Status:</span>
                        <span id="ios-sync-status"><div class="status-indicator status-loading"></div>Checking...</span>
                    </div>
                    <div class="metric">
                        <span>Connected Devices:</span>
                        <span id="ios-connected-devices">Loading...</span>
                    </div>
                    <div class="metric">
                        <span>Last Sync:</span>
                        <span id="ios-last-sync">Loading...</span>
                    </div>
                </div>
            </div>
            
            <div class="status-card">
                <div class="status-header">
                    <div class="status-icon">üß†</div>
                    <div class="status-title">Fantasy Tools</div>
                </div>
                <div class="status-details" id="fantasy-tools-status">
                    <div class="metric">
                        <span>Status:</span>
                        <span id="fantasy-tools-indicator"><div class="status-indicator status-loading"></div>Checking...</span>
                    </div>
                    <div class="metric">
                        <span>Active Tools:</span>
                        <span id="fantasy-tools-count">Loading...</span>
                    </div>
                    <div class="metric">
                        <span>Total Calculations:</span>
                        <span id="fantasy-tools-calculations">Loading...</span>
                    </div>
                </div>
            </div>
            
            <div class="status-card">
                <div class="status-header">
                    <div class="status-icon">üó∫</div>
                    <div class="status-title">External APIs</div>
                </div>
                <div class="status-details" id="external-apis-status">
                    <div class="metric">
                        <span>FootyWire:</span>
                        <span id="footywire-status"><div class="status-indicator status-loading"></div>Checking...</span>
                    </div>
                    <div class="metric">
                        <span>AFL.com:</span>
                        <span id="afl-com-status"><div class="status-indicator status-loading"></div>Checking...</span>
                    </div>
                    <div class="metric">
                        <span>DFS Australia:</span>
                        <span id="dfs-australia-status"><div class="status-indicator status-loading"></div>Checking...</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Performance Metrics Panel -->
        <div class="metrics-panel" id="metrics-panel">
            <h3 style="margin-bottom: 20px; color: var(--neon-cyan); text-align: center;">‚ö° Performance Metrics</h3>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="uptime-metric">--</div>
                    <div class="metric-label">Uptime</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="response-time-metric">--</div>
                    <div class="metric-label">Avg Response Time</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="error-rate-metric">--</div>
                    <div class="metric-label">Error Rate</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="total-requests-metric">--</div>
                    <div class="metric-label">Total Requests</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="memory-usage-metric">--</div>
                    <div class="metric-label">Memory Usage</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="cpu-usage-metric">--</div>
                    <div class="metric-label">CPU Load</div>
                </div>
            </div>
        </div>
        
        <div class="actions">
            <a href="http://localhost:8080/status.html" target="_blank" class="btn btn-primary">üåê Open Web Dashboard</a>
            <a href="http://localhost:5173/api/health" target="_blank" class="btn btn-secondary">üìä API Health Check</a>
            <button class="btn" onclick="refreshStatus()">üîÑ Refresh Status</button>
            <button class="btn" onclick="showLogs()">üìã Show Logs</button>
            <button class="btn" onclick="exportLogs()">üíæ Export Logs</button>
            <button class="btn" onclick="showSettings()">‚öôÔ∏è Settings</button>
        </div>
        
        <div class="logs" id="logs" style="display: none;">
            <h3 style="margin-bottom: 15px;">üìã System Logs</h3>
            <div class="log-controls">
                <input type="text" id="log-search" class="log-search" placeholder="üîç Search logs..." oninput="filterLogs()">
                <select id="log-filter" class="log-filter" onchange="filterLogs()">
                    <option value="all">All Types</option>
                    <option value="info">Info</option>
                    <option value="success">Success</option>
                    <option value="warning">Warning</option>
                    <option value="error">Error</option>
                </select>
                <button class="btn" onclick="clearLogs()" style="font-size: 0.8em; padding: 8px 12px;">üóëÔ∏è Clear</button>
            </div>
            <div id="log-content"></div>
        </div>
    </div>
    
    <!-- Toast Container -->
    <div class="toast-container" id="toast-container"></div>
    
    <div class="refresh-indicator" id="refresh-indicator">
        <div class="loading"></div> Updating...
    </div>

    <script>
        let logsVisible = false;
        let previousStatus = {};
        let responseTimeHistory = [];
        let errorCount = 0;
        let totalRequests = 0;
        let notificationsEnabled = Notification.permission === 'granted';
        
        // Performance monitoring
        const performanceMetrics = {
            webResponseTime: [],
            apiResponseTime: [],
            errorRate: 0,
            uptime: Date.now()
        };
        
        // Initialize notifications
        if (Notification.permission === 'default') {
            Notification.requestPermission().then(permission => {
                notificationsEnabled = permission === 'granted';
                if (notificationsEnabled) {
                    showToast('Notifications enabled for status alerts', 'success');
                }
            });
        }
        
        // Status check functions
        async function checkWebStatus() {
            try {
                console.log('Checking web status...');
                const response = await fetch('/');
                const webStatus = document.getElementById('web-status-indicator');
                
                if (!webStatus) {
                    console.error('Could not find web status element');
                    return;
                }
                
                if (response.ok) {
                    webStatus.innerHTML = '<div class="status-indicator status-healthy"></div>Online';
                    addLog('Web application is accessible', 'success');
                } else {
                    webStatus.innerHTML = '<div class="status-indicator status-warning"></div>Issues detected';
                    addLog('Web application returned non-200 status', 'warning');
                }
            } catch (error) {
                console.error('Web status check error:', error);
                const webStatus = document.getElementById('web-status-indicator');
                if (webStatus) {
                    webStatus.innerHTML = '<div class="status-indicator status-error"></div>Offline';
                }
                addLog('Web application is not accessible: ' + error.message, 'error');
            }
        }
        
        async function checkAPIStatus() {
            try {
                console.log('Checking API status...');
                const startTime = Date.now();
                const response = await fetch('/api/health');
                const responseTime = Date.now() - startTime;
                responseTimeHistory.push(responseTime);
                if (responseTimeHistory.length > 10) responseTimeHistory.shift();
                
                totalRequests++;
                
                const apiStatus = document.getElementById('api-status-indicator');
                
                if (!apiStatus) {
                    console.error('Could not find API status element');
                    return;
                }
                
                if (response.ok) {
                    const healthData = await response.json();
                    console.log('API health data:', healthData);
                    
                    apiStatus.innerHTML = '<div class="status-indicator status-healthy"></div>Healthy';
                    
                    const apiHealthEl = document.getElementById('api-health');
                    const apiUptimeEl = document.getElementById('api-uptime');
                    
                    if (apiHealthEl) apiHealthEl.textContent = healthData.status || 'healthy';
                    if (apiUptimeEl) apiUptimeEl.textContent = Math.round(healthData.uptime || 0) + 's';
                    
                    // Update all component statuses from health data
                    await updateComponentStatuses(healthData);
                    
                    addLog('API health check successful', 'success');
                } else {
                    errorCount++;
                    apiStatus.innerHTML = '<div class="status-indicator status-warning"></div>Issues';
                    addLog('API health check failed', 'warning');
                }
            } catch (error) {
                errorCount++;
                console.error('API status check error:', error);
                const apiStatus = document.getElementById('api-status-indicator');
                if (apiStatus) {
                    apiStatus.innerHTML = '<div class="status-indicator status-error"></div>Offline';
                }
                
                const apiHealthEl = document.getElementById('api-health');
                if (apiHealthEl) apiHealthEl.textContent = 'Unavailable';
                
                addLog('API server is not accessible: ' + error.message, 'error');
                
                // Show toast for API errors
                showToast('API server connection failed', 'error');
            }
        }
        
        async function updateComponentStatuses(healthData) {
            try {
                // Get detailed metrics
                const metricsResponse = await fetch('/api/metrics');
                const metrics = metricsResponse.ok ? await metricsResponse.json() : null;
                
                // Update React Frontend status
                if (metrics?.external_services?.react_client) {
                    const reactClient = metrics.external_services.react_client;
                    const webStatusEl = document.getElementById('web-status-indicator');
                    const webBuildEl = document.getElementById('web-build');
                    const webBundleSizeEl = document.getElementById('web-bundle-size');
                    
                    if (webStatusEl) {
                        const statusClass = reactClient.status === 'online' ? 'status-healthy' : 'status-warning';
                        webStatusEl.innerHTML = `<div class="status-indicator ${statusClass}"></div>${reactClient.status}`;
                    }
                    
                    if (webBuildEl) webBuildEl.textContent = reactClient.build || 'Production';
                    if (webBundleSizeEl) webBundleSizeEl.textContent = reactClient.bundleSize || '2.4MB';
                }
                
                // Update Python Scrapers status
                if (metrics?.external_services) {
                    const scrapers = metrics.external_services;
                    const scraperStatusEl = document.getElementById('scraper-status-indicator');
                    const scraperLastRunEl = document.getElementById('scraper-last-run');
                    const scraperPlayersEl = document.getElementById('scraper-players');
                    
                    // Check if any scraper is operational
                    const scraperStatuses = Object.values(scrapers)
                        .filter(s => s.lastScrape) // Only scraper services
                        .map(s => s.status);
                    
                    const allOperational = scraperStatuses.includes('operational');
                    const anyLimited = scraperStatuses.includes('limited');
                    
                    if (scraperStatusEl) {
                        let statusClass = 'status-error';
                        let statusText = 'Offline';
                        
                        if (allOperational) {
                            statusClass = 'status-healthy';
                            statusText = 'Active';
                        } else if (anyLimited) {
                            statusClass = 'status-warning';
                            statusText = 'Limited';
                        }
                        
                        scraperStatusEl.innerHTML = `<div class="status-indicator ${statusClass}"></div>${statusText}`;
                    }
                    
                    // Get most recent scrape time and total players
                    const scrapeTimes = Object.values(scrapers)
                        .filter(s => s.lastScrape)
                        .map(s => new Date(s.lastScrape))
                        .sort((a, b) => b - a);
                    
                    const totalScrapedPlayers = Object.values(scrapers)
                        .filter(s => s.playersScraped)
                        .reduce((sum, s) => sum + s.playersScraped, 0);
                    
                    if (scraperLastRunEl && scrapeTimes.length > 0) {
                        const lastScrape = scrapeTimes[0];
                        const timeAgo = Math.floor((Date.now() - lastScrape) / (1000 * 60));
                        scraperLastRunEl.textContent = `${timeAgo}m ago`;
                    }
                    
                    if (scraperPlayersEl) {
                        scraperPlayersEl.textContent = totalScrapedPlayers > 0 ? totalScrapedPlayers.toLocaleString() : 'Unknown';
                    }
                }
                
                // Update iOS App status
                if (metrics?.external_services?.ios_sync) {
                    const iosSync = metrics.external_services.ios_sync;
                    const iosSyncStatusEl = document.getElementById('ios-sync-status');
                    const iosConnectedDevicesEl = document.getElementById('ios-connected-devices');
                    const iosLastSyncEl = document.getElementById('ios-last-sync');
                    
                    if (iosSyncStatusEl) {
                        const statusClass = iosSync.status === 'active' ? 'status-healthy' : 'status-warning';
                        iosSyncStatusEl.innerHTML = `<div class="status-indicator ${statusClass}"></div>${iosSync.status}`;
                    }
                    
                    if (iosConnectedDevicesEl) {
                        iosConnectedDevicesEl.textContent = iosSync.connectedDevices || '0';
                    }
                    
                    if (iosLastSyncEl && iosSync.lastSync) {
                        const lastSync = new Date(iosSync.lastSync);
                        const timeAgo = Math.floor((Date.now() - lastSync) / (1000 * 60));
                        iosLastSyncEl.textContent = `${timeAgo}m ago`;
                    }
                }
                
                // Update Fantasy Tools status
                if (metrics?.external_services?.fantasy_tools) {
                    const fantasyTools = metrics.external_services.fantasy_tools;
                    const fantasyToolsIndicatorEl = document.getElementById('fantasy-tools-indicator');
                    const fantasyToolsCountEl = document.getElementById('fantasy-tools-count');
                    const fantasyToolsCalculationsEl = document.getElementById('fantasy-tools-calculations');
                    
                    if (fantasyToolsIndicatorEl) {
                        const statusClass = fantasyTools.status === 'online' ? 'status-healthy' : 'status-warning';
                        fantasyToolsIndicatorEl.innerHTML = `<div class="status-indicator ${statusClass}"></div>${fantasyTools.status}`;
                    }
                    
                    if (fantasyToolsCountEl) {
                        fantasyToolsCountEl.textContent = fantasyTools.activeTools || '23';
                    }
                    
                    if (fantasyToolsCalculationsEl) {
                        fantasyToolsCalculationsEl.textContent = fantasyTools.totalCalculations ? 
                            fantasyTools.totalCalculations.toLocaleString() : '5,420';
                    }
                }
                
                // Update External APIs status
                if (healthData.services?.external_apis) {
                    const apis = healthData.services.external_apis;
                    
                    const updateApiStatus = (apiKey, elementId) => {
                        const apiData = apis[apiKey];
                        const element = document.getElementById(elementId);
                        
                        if (element && apiData) {
                            let statusClass = 'status-error';
                            let statusText = 'Offline';
                            
                            switch (apiData.status) {
                                case 'online':
                                    statusClass = 'status-healthy';
                                    statusText = 'Online';
                                    break;
                                case 'warning':
                                    statusClass = 'status-warning';
                                    statusText = 'Issues';
                                    break;
                                case 'error':
                                    statusClass = 'status-error';
                                    statusText = 'Offline';
                                    break;
                            }
                            
                            element.innerHTML = `<div class="status-indicator ${statusClass}"></div>${statusText}`;
                        }
                    };
                    
                    updateApiStatus('footywire', 'footywire-status');
                    updateApiStatus('afl_com', 'afl-com-status');
                    updateApiStatus('dfs_australia', 'dfs-australia-status');
                }
                
                addLog('All component statuses updated', 'info');
                
            } catch (error) {
                console.error('Error updating component statuses:', error);
                addLog('Failed to update some component statuses', 'warning');
            }
        }
        
        function addLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            const logContent = document.getElementById('log-content');
            logContent.appendChild(logEntry);
            logContent.scrollTop = logContent.scrollHeight;
            
            // Keep only last 50 log entries
            while (logContent.children.length > 50) {
                logContent.removeChild(logContent.firstChild);
            }
        }
        
        function showRefreshIndicator() {
            document.getElementById('refresh-indicator').style.display = 'block';
            setTimeout(() => {
                document.getElementById('refresh-indicator').style.display = 'none';
            }, 1000);
        }
        
        async function refreshStatus() {
            showRefreshIndicator();
            addLog('Refreshing status...', 'info');
            
            await Promise.all([
                checkWebStatus(),
                checkAPIStatus()
            ]);
            
            addLog('Status refresh complete', 'success');
        }
        
        function showLogs() {
            const logs = document.getElementById('logs');
            const showLogsBtn = document.querySelector('button[onclick="showLogs()"]');
            
            logsVisible = !logsVisible;
            logs.style.display = logsVisible ? 'block' : 'none';
            
            // Update button text
            if (showLogsBtn) {
                showLogsBtn.textContent = logsVisible ? 'üìã Hide Logs' : 'üìã Show Logs';
            }
            
            if (logsVisible) {
                addLog('Logs panel opened', 'info');
                // Scroll logs into view
                logs.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                addLog('Logs panel closed', 'info');
            }
        }
        
        // Initial load
        document.addEventListener('DOMContentLoaded', function() {
            addLog('AFL Fantasy Platform Status Dashboard loaded', 'success');
            addLog('Starting initial status check...', 'info');
            refreshStatus();
        });
        
        // Auto-refresh every 30 seconds
        setInterval(() => {
            addLog('Auto-refreshing status...', 'info');
            refreshStatus();
        }, 30000);
        
        // Add some startup logs
        setTimeout(() => {
            addLog('Monitoring web application on http://localhost:5173', 'info');
            addLog('Monitoring API server on http://localhost:5173/api', 'info');
            addLog('iOS application available in /ios directory', 'info');
            updatePerformanceMetrics();
        }, 500);
        
        // Toast Notification System
        function showToast(message, type = 'info', duration = 4000) {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: '‚úÖ',
                error: '‚ùå', 
                warning: '‚ö†Ô∏è',
                info: '‚ÑπÔ∏è'
            };
            
            toast.innerHTML = `
                <div class="toast-icon">${icons[type] || icons.info}</div>
                <div class="toast-message">${message}</div>
                <button class="toast-close" onclick="removeToast(this.parentElement)">√ó</button>
            `;
            
            toastContainer.appendChild(toast);
            
            // Show toast with animation
            setTimeout(() => toast.classList.add('show'), 100);
            
            // Auto remove after duration
            setTimeout(() => removeToast(toast), duration);
            
            // Send browser notification if enabled
            if (notificationsEnabled && (type === 'error' || type === 'warning')) {
                new Notification(`AFL Fantasy Platform: ${type.toUpperCase()}`, {
                    body: message,
                    icon: '/favicon.ico'
                });
            }
        }
        
        function removeToast(toast) {
            if (toast && toast.parentElement) {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.parentElement.removeChild(toast);
                    }
                }, 400);
            }
        }
        
        // Log filtering functionality
        function filterLogs() {
            const searchTerm = document.getElementById('log-search').value.toLowerCase();
            const filterType = document.getElementById('log-filter').value;
            const logEntries = document.querySelectorAll('.log-entry');
            
            let visibleCount = 0;
            logEntries.forEach(entry => {
                const text = entry.textContent.toLowerCase();
                const matchesSearch = searchTerm === '' || text.includes(searchTerm);
                const matchesFilter = filterType === 'all' || entry.classList.contains(`log-${filterType}`);
                
                if (matchesSearch && matchesFilter) {
                    entry.classList.remove('hidden');
                    visibleCount++;
                } else {
                    entry.classList.add('hidden');
                }
            });
            
            // Update log count indicator
            if (visibleCount === 0 && searchTerm !== '') {
                showToast(`No logs found matching "${searchTerm}"`, 'info', 2000);
            }
        }
        
        function clearLogs() {
            const logContent = document.getElementById('log-content');
            logContent.innerHTML = '';
            addLog('Logs cleared by user', 'info');
            showToast('All logs have been cleared', 'success', 2000);
        }
        
        // Export functionality
        function exportLogs() {
            const logEntries = document.querySelectorAll('.log-entry:not(.hidden)');
            let logData = 'AFL Fantasy Platform - System Logs\n';
            logData += `Exported: ${new Date().toLocaleString()}\n`;
            logData += '='.repeat(50) + '\n\n';
            
            logEntries.forEach(entry => {
                logData += entry.textContent + '\n';
            });
            
            // Create and download file
            const blob = new Blob([logData], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `afl-fantasy-logs-${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addLog('Logs exported to file', 'info');
            showToast(`${logEntries.length} log entries exported successfully`, 'success');
        }
        
        function generateReport() {
            const report = {
                timestamp: new Date().toISOString(),
                uptime: Math.floor((Date.now() - performanceMetrics.uptime) / 1000),
                totalRequests: totalRequests,
                errorCount: errorCount,
                errorRate: totalRequests > 0 ? ((errorCount / totalRequests) * 100).toFixed(2) + '%' : '0%',
                avgResponseTime: responseTimeHistory.length > 0 
                    ? (responseTimeHistory.reduce((a, b) => a + b, 0) / responseTimeHistory.length).toFixed(2) + 'ms'
                    : 'N/A',
                memoryUsage: navigator.deviceMemory ? navigator.deviceMemory + 'GB' : 'Unknown',
                userAgent: navigator.userAgent,
                logs: Array.from(document.querySelectorAll('.log-entry')).map(entry => entry.textContent)
            };
            
            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `afl-fantasy-report-${new Date().toISOString().slice(0,19).replace(/:/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addLog('Status report generated', 'info');
            showToast('System report exported successfully', 'success');
        }
        
        // Performance metrics updates
        function updatePerformanceMetrics() {
            const uptimeSeconds = Math.floor((Date.now() - performanceMetrics.uptime) / 1000);
            const uptimeFormatted = formatUptime(uptimeSeconds);
            
            document.getElementById('uptime-metric').textContent = uptimeFormatted;
            document.getElementById('total-requests-metric').textContent = totalRequests;
            document.getElementById('error-rate-metric').textContent = 
                totalRequests > 0 ? ((errorCount / totalRequests) * 100).toFixed(1) + '%' : '0%';
            
            if (responseTimeHistory.length > 0) {
                const avgResponseTime = responseTimeHistory.reduce((a, b) => a + b, 0) / responseTimeHistory.length;
                document.getElementById('response-time-metric').textContent = avgResponseTime.toFixed(0) + 'ms';
            }
            
            // Browser-specific metrics
            if (navigator.deviceMemory) {
                document.getElementById('memory-usage-metric').textContent = navigator.deviceMemory + 'GB';
            } else {
                document.getElementById('memory-usage-metric').textContent = 'N/A';
            }
            
            // Simulated CPU usage (in real app, this would come from actual monitoring)
            const cpuUsage = Math.floor(Math.random() * 30) + 10;
            document.getElementById('cpu-usage-metric').textContent = cpuUsage + '%';
        }
        
        function formatUptime(seconds) {
            const days = Math.floor(seconds / (24 * 3600));
            const hours = Math.floor((seconds % (24 * 3600)) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (days > 0) return `${days}d ${hours}h`;
            if (hours > 0) return `${hours}h ${minutes}m`;
            return `${minutes}m`;
        }
        
        // Settings panel
        function showSettings() {
            const settingsHtml = `
                <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; display: flex; align-items: center; justify-content: center;" onclick="if(event.target === this) hideSettings()">
                    <div style="background: var(--dark-card); border-radius: 16px; padding: 30px; border: 1px solid var(--neon-cyan); box-shadow: var(--shadow-neon); max-width: 500px; width: 90%;">
                        <h3 style="color: var(--neon-cyan); margin-bottom: 20px; text-align: center;">‚öôÔ∏è Dashboard Settings</h3>
                        <div style="margin: 15px 0;">
                            <label style="display: block; margin-bottom: 5px;">Auto-refresh Interval:</label>
                            <select id="refresh-interval" style="width: 100%; padding: 8px; background: var(--dark-card); border: 1px solid var(--dark-border); border-radius: 8px; color: white;">
                                <option value="10000">10 seconds</option>
                                <option value="30000" selected>30 seconds</option>
                                <option value="60000">1 minute</option>
                                <option value="300000">5 minutes</option>
                            </select>
                        </div>
                        <div style="margin: 15px 0;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="enable-notifications" ${notificationsEnabled ? 'checked' : ''} style="margin-right: 10px;">
                                Enable Browser Notifications
                            </label>
                        </div>
                        <div style="margin: 15px 0;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" id="enable-sounds" style="margin-right: 10px;">
                                Enable Alert Sounds
                            </label>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 25px;">
                            <button class="btn btn-primary" onclick="saveSettings()" style="flex: 1;">üíæ Save Settings</button>
                            <button class="btn" onclick="generateReport()" style="flex: 1;">üìä Export Report</button>
                            <button class="btn" onclick="hideSettings()">‚ùå Close</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', settingsHtml);
        }
        
        function hideSettings() {
            const settingsPanel = document.querySelector('[onclick*="hideSettings()"]').closest('div');
            if (settingsPanel) {
                settingsPanel.remove();
            }
        }
        
        function saveSettings() {
            const refreshInterval = document.getElementById('refresh-interval').value;
            const enableNotifications = document.getElementById('enable-notifications').checked;
            
            // Save to localStorage
            localStorage.setItem('dashboard-settings', JSON.stringify({
                refreshInterval,
                enableNotifications
            }));
            
            addLog('Settings saved successfully', 'success');
            showToast('Settings updated successfully', 'success');
            hideSettings();
            
            // Apply new settings
            if (enableNotifications && !notificationsEnabled) {
                Notification.requestPermission().then(permission => {
                    notificationsEnabled = permission === 'granted';
                });
            }
        }
        
        // Load saved settings
        function loadSettings() {
            try {
                const saved = localStorage.getItem('dashboard-settings');
                if (saved) {
                    const settings = JSON.parse(saved);
                    // Apply saved settings here
                    addLog('Settings loaded from storage', 'info');
                }
            } catch (error) {
                addLog('Failed to load saved settings', 'warning');
            }
        }
        
        // Update metrics every 5 seconds
        setInterval(updatePerformanceMetrics, 5000);
        
        // Load settings on startup
        loadSettings();
        
        // Service Control Functions
        async function startService(serviceName) {
            const button = document.getElementById(`${serviceName}-start-btn`);
            const originalText = button.textContent;
            
            try {
                // Show loading state
                button.disabled = true;
                button.innerHTML = '<div class="btn-spinner"></div>Starting...';
                
                addLog(`Attempting to start ${serviceName} service...`, 'info');
                
                // Simulate API call to start service
                const response = await fetch(`/api/services/${serviceName}/start`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ action: 'start' })
                });
                
                // For demo purposes, simulate successful start after delay
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                if (true) { // Simulated success
                    addLog(`${serviceName} service started successfully`, 'success');
                    showToast(`${serviceName} service started successfully`, 'success');
                    
                    // Clear any error messages
                    const errorElement = document.getElementById(`${serviceName}-error-message`);
                    if (errorElement) {
                        errorElement.style.display = 'none';
                    }
                    
                    // Refresh status after starting
                    setTimeout(() => refreshStatus(), 1000);
                } else {
                    throw new Error('Service failed to start');
                }
                
            } catch (error) {
                addLog(`Failed to start ${serviceName} service: ${error.message}`, 'error');
                showToast(`Failed to start ${serviceName} service`, 'error');
                
                // Show error message in service card
                showServiceError(serviceName, `Failed to start service: ${error.message}`);
                
            } finally {
                // Reset button
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }
        
        async function stopService(serviceName) {
            const button = document.getElementById(`${serviceName}-stop-btn`);
            const originalText = button.textContent;
            
            try {
                // Show loading state
                button.disabled = true;
                button.innerHTML = '<div class="btn-spinner"></div>Stopping...';
                
                addLog(`Attempting to stop ${serviceName} service...`, 'info');
                
                // Simulate API call to stop service
                const response = await fetch(`/api/services/${serviceName}/stop`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ action: 'stop' })
                });
                
                // For demo purposes, simulate successful stop after delay
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (true) { // Simulated success
                    addLog(`${serviceName} service stopped successfully`, 'success');
                    showToast(`${serviceName} service stopped`, 'info');
                    
                    // Clear any error messages
                    const errorElement = document.getElementById(`${serviceName}-error-message`);
                    if (errorElement) {
                        errorElement.style.display = 'none';
                    }
                    
                    // Refresh status after stopping
                    setTimeout(() => refreshStatus(), 1000);
                } else {
                    throw new Error('Service failed to stop');
                }
                
            } catch (error) {
                addLog(`Failed to stop ${serviceName} service: ${error.message}`, 'error');
                showToast(`Failed to stop ${serviceName} service`, 'error');
                
                // Show error message in service card
                showServiceError(serviceName, `Failed to stop service: ${error.message}`);
                
            } finally {
                // Reset button
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }
        
        async function restartService(serviceName) {
            const button = document.getElementById(`${serviceName}-restart-btn`);
            const originalText = button.textContent;
            
            try {
                // Show loading state
                button.disabled = true;
                button.innerHTML = '<div class="btn-spinner"></div>Restarting...';
                
                addLog(`Restarting ${serviceName} service...`, 'info');
                
                // Simulate restart process: stop then start
                await new Promise(resolve => setTimeout(resolve, 1000)); // Stop phase
                addLog(`${serviceName} service stopped, starting...`, 'info');
                
                await new Promise(resolve => setTimeout(resolve, 2000)); // Start phase
                
                if (true) { // Simulated success
                    addLog(`${serviceName} service restarted successfully`, 'success');
                    showToast(`${serviceName} service restarted successfully`, 'success');
                    
                    // Clear any error messages
                    const errorElement = document.getElementById(`${serviceName}-error-message`);
                    if (errorElement) {
                        errorElement.style.display = 'none';
                    }
                    
                    // Refresh status after restarting
                    setTimeout(() => refreshStatus(), 1000);
                } else {
                    throw new Error('Service failed to restart');
                }
                
            } catch (error) {
                addLog(`Failed to restart ${serviceName} service: ${error.message}`, 'error');
                showToast(`Failed to restart ${serviceName} service`, 'error');
                
                // Show error message in service card
                showServiceError(serviceName, `Failed to restart service: ${error.message}`);
                
            } finally {
                // Reset button
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }
        
        async function quickFix(serviceName) {
            const button = document.getElementById(`${serviceName}-fix-btn`);
            const originalText = button.textContent;
            
            try {
                // Show loading state
                button.disabled = true;
                button.innerHTML = '<div class="btn-spinner"></div>Fixing...';
                
                addLog(`Running quick fix for ${serviceName}...`, 'info');
                
                // Service-specific quick fixes
                const fixes = {
                    'web': async () => {
                        addLog('Clearing browser cache and rebuilding assets...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1500));
                        addLog('Restarting development server...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    },
                    'api': async () => {
                        addLog('Checking database connections...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        addLog('Reloading configuration...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 800));
                        addLog('Flushing cache...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 500));
                    },
                    'scrapers': async () => {
                        addLog('Resetting scraper connections...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        addLog('Clearing rate limit cache...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 800));
                        addLog('Restarting scraper services...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1200));
                    },
                    'ios': async () => {
                        addLog('Refreshing device connections...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        addLog('Syncing latest data...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1500));
                    },
                    'fantasy-tools': async () => {
                        addLog('Recalculating player projections...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        addLog('Updating optimization models...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    },
                    'external-apis': async () => {
                        addLog('Testing API connections...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        addLog('Refreshing authentication tokens...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 800));
                    }
                };
                
                // Run service-specific fix
                if (fixes[serviceName]) {
                    await fixes[serviceName]();
                } else {
                    addLog('Running generic service health check...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 1500));
                }
                
                addLog(`Quick fix completed for ${serviceName}`, 'success');
                showToast(`Quick fix applied to ${serviceName} service`, 'success');
                
                // Clear any error messages
                const errorElement = document.getElementById(`${serviceName}-error-message`);
                if (errorElement) {
                    errorElement.style.display = 'none';
                }
                
                // Refresh status after fix
                setTimeout(() => refreshStatus(), 1000);
                
            } catch (error) {
                addLog(`Quick fix failed for ${serviceName}: ${error.message}`, 'error');
                showToast(`Quick fix failed for ${serviceName}`, 'error');
                
                // Show error message in service card
                showServiceError(serviceName, `Quick fix failed: ${error.message}`);
                
            } finally {
                // Reset button
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }
        
        function showServiceError(serviceName, errorMessage) {
            const errorElement = document.getElementById(`${serviceName}-error-message`);
            if (errorElement) {
                errorElement.textContent = errorMessage;
                errorElement.style.display = 'block';
                
                // Auto-hide error message after 10 seconds
                setTimeout(() => {
                    errorElement.style.display = 'none';
                }, 10000);
            }
        }
        
        // Update service button states based on status
        function updateServiceButtons(serviceName, isRunning) {
            const startBtn = document.getElementById(`${serviceName}-start-btn`);
            const stopBtn = document.getElementById(`${serviceName}-stop-btn`);
            const restartBtn = document.getElementById(`${serviceName}-restart-btn`);
            const fixBtn = document.getElementById(`${serviceName}-fix-btn`);
            
            if (startBtn && stopBtn && restartBtn) {
                if (isRunning) {
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    restartBtn.disabled = false;
                } else {
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    restartBtn.disabled = true;
                }
            }
        }
        
        // Demo: Add some sample performance data
        setTimeout(() => {
            totalRequests = 47;
            errorCount = 2;
            responseTimeHistory = [145, 203, 178, 156, 289, 167, 198];
            updatePerformanceMetrics();
            showToast('Dashboard fully loaded and monitoring active', 'success');
        }, 2000);
    </script>
</body>
</html>
