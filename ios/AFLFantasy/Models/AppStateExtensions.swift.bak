//
//  AppStateExtensions.swift
//  AFL Fantasy Intelligence Platform
//
//  Extensions and missing models for enhanced trade functionality
//  Created by AI Assistant on 6/9/2025.
//

import Foundation
import SwiftUI

// MARK: - EnhancedPlayer

struct EnhancedPlayer: Identifiable, Codable {
    let id: String
    let name: String
    let position: Position
    let price: Int
    let currentScore: Int
    let averageScore: Double
    let breakeven: Int
    let consistency: Double
    let highScore: Int
    let lowScore: Int
    let priceChange: Int
    let isCashCow: Bool
    let isDoubtful: Bool
    let isSuspended: Bool
    let cashGenerated: Int
    let projectedPeakPrice: Int
    let nextRoundProjection: RoundProjection
    let seasonProjection: SeasonProjection
    let injuryRisk: InjuryRisk
    let venuePerformance: [VenuePerformance]
    let alertFlags: [AlertFlag]

    var formattedPrice: String {
        "$\(Double(price) / 1000, specifier: "%.1f")k"
    }

    var priceChangeText: String {
        let prefix = priceChange >= 0 ? "+" : ""
        return "\(prefix)\(priceChange)"
    }

    var formattedPriceChange: String {
        let prefix = priceChange >= 0 ? "+" : ""
        return "\(prefix)$\(abs(priceChange))"
    }

    var consistencyGrade: String {
        switch consistency {
        case 90...: "A+"
        case 80 ..< 90: "A"
        case 70 ..< 80: "B"
        case 60 ..< 70: "C"
        default: "D"
        }
    }
}

// MARK: - Position

enum Position: String, CaseIterable, Codable {
    case defender = "DEF"
    case midfielder = "MID"
    case ruck = "RUC"
    case forward = "FWD"

    var color: Color {
        switch self {
        case .defender: .blue
        case .midfielder: .green
        case .ruck: .purple
        case .forward: .red
        }
    }

    var shortName: String {
        switch self {
        case .defender: "DEF"
        case .midfielder: "MID"
        case .ruck: "RUC"
        case .forward: "FWD"
        }
    }
}

// MARK: - RoundProjection

struct RoundProjection: Identifiable, Codable {
    let id = UUID()
    let round: Int
    let opponent: String
    let venue: String
    let projectedScore: Double
    let confidence: Double
    let conditions: WeatherConditions

    init(
        round: Int,
        opponent: String,
        venue: String,
        projectedScore: Double,
        confidence: Double,
        conditions: WeatherConditions
    ) {
        self.round = round
        self.opponent = opponent
        self.venue = venue
        self.projectedScore = projectedScore
        self.confidence = confidence
        self.conditions = conditions
    }
}

// MARK: - WeatherConditions

struct WeatherConditions: Codable {
    let temperature: Double
    let rainProbability: Double
    let windSpeed: Double
    let humidity: Double
}

// MARK: - SeasonProjection

struct SeasonProjection: Codable {
    let projectedTotalScore: Double
    let projectedAverage: Double
    let premiumPotential: Double
}

// MARK: - InjuryRisk

struct InjuryRisk: Codable {
    let riskLevel: InjuryRiskLevel
    let riskScore: Double
    let riskFactors: [String]
}

// MARK: - InjuryRiskLevel

enum InjuryRiskLevel: String, CaseIterable, Codable {
    case low = "Low"
    case medium = "Medium"
    case high = "High"
    case critical = "Critical"

    var color: Color {
        switch self {
        case .low: .green
        case .medium: .yellow
        case .high: .orange
        case .critical: .red
        }
    }
}

// MARK: - VenuePerformance

struct VenuePerformance: Identifiable, Codable {
    let id = UUID()
    let venue: String
    let gamesPlayed: Int
    let averageScore: Double
    let bias: Double

    init(venue: String, gamesPlayed: Int, averageScore: Double, bias: Double) {
        self.venue = venue
        self.gamesPlayed = gamesPlayed
        self.averageScore = averageScore
        self.bias = bias
    }
}

// MARK: - AlertFlag

struct AlertFlag: Identifiable, Codable {
    let id = UUID()
    let type: AlertType
    let priority: AlertPriority
    let message: String

    init(type: AlertType, priority: AlertPriority, message: String) {
        self.type = type
        self.priority = priority
        self.message = message
    }
}

// MARK: - AlertType

enum AlertType: String, CaseIterable, Codable {
    case injury = "injury"
    case priceRise = "priceRise"
    case priceDrop = "priceDrop"
    case breakeven = "breakeven"
    case captain = "captain"
    case trade = "trade"
    case suspension = "suspension"
    case teamChange = "teamChange"
    case breakEvenCliff
    case cashCowSell
    case injuryRisk
    case roleChange
    case weatherRisk
    case contractYear
    case premiumBreakout
}

// MARK: - AlertPriority

enum AlertPriority: String, CaseIterable, Codable {
    case critical
    case high
    case medium
    case low
}

// MARK: - CaptainSuggestion

struct CaptainSuggestion: Identifiable, Codable {
    let id = UUID()
    let player: EnhancedPlayer
    let confidence: Double
    let projectedScore: Double
    let formRating: Double
    let fixtureRating: Double
    let riskFactor: Double
    let opponent: String
    
    // Computed properties for ContentView compatibility
    var playerName: String { player.name }
    var position: String { player.position.rawValue }
    var positionColor: Color { player.position.color }

    init(
        player: EnhancedPlayer, 
        confidence: Double, 
        projectedScore: Double,
        formRating: Double = 0.8,
        fixtureRating: Double = 0.7,
        riskFactor: Double = 0.2,
        opponent: String = "TBD"
    ) {
        self.player = player
        self.confidence = confidence
        self.projectedScore = projectedScore
        self.formRating = formRating
        self.fixtureRating = fixtureRating
        self.riskFactor = riskFactor
        self.opponent = opponent
    }
}

// MARK: - TradeRecord

struct TradeRecord: Identifiable, Codable {
    let id: UUID
    let playerOut: EnhancedPlayer
    let playerIn: EnhancedPlayer
    let executedAt: Date
    let netCost: Int
    let projectedImpact: Double

    init(
        id: UUID = UUID(),
        playerOut: EnhancedPlayer,
        playerIn: EnhancedPlayer,
        executedAt: Date,
        netCost: Int,
        projectedImpact: Double
    ) {
        self.id = id
        self.playerOut = playerOut
        self.playerIn = playerIn
        self.executedAt = executedAt
        self.netCost = netCost
        self.projectedImpact = projectedImpact
    }
}

// MARK: - TabItem

enum TabItem: String, CaseIterable {
    case dashboard = "Dashboard"
    case captain = "Captain"
    case trades = "Trades"
    case cashCow = "Cash Cow"
    case settings = "Settings"

    var systemImage: String {
        switch self {
        case .dashboard: "house.fill"
        case .captain: "star.fill"
        case .trades: "arrow.triangle.2.circlepath"
        case .cashCow: "dollarsign.circle.fill"
        case .settings: "gearshape.fill"
        }
    }
}

// MARK: - ConnectionStatus

enum ConnectionStatus: String, CaseIterable {
    case disconnected = "Offline"
    case connecting = "Connecting"
    case connected = "Connected"
    case live = "Live Data"
    case error = "Error"

    var systemImage: String {
        switch self {
        case .disconnected: "wifi.slash"
        case .connecting: "wifi.exclamationmark"
        case .connected: "wifi"
        case .live: "dot.radiowaves.left.and.right"
        case .error: "exclamationmark.triangle"
        }
    }

    var color: Color {
        switch self {
        case .disconnected: .gray
        case .connecting: .orange
        case .connected: .green
        case .live: .red
        case .error: .red
        }
    }
}

// MARK: - AppState Type Alias

typealias AppState = PersistentAppState

// MARK: - AppState Extensions

extension PersistentAppState {
    // Connection status
    @Published var connectionStatus: ConnectionStatus = .connected
    @Published var isRefreshing: Bool = false
    @Published var lastUpdateTime: Date? = Date()
    @Published var errorMessage: String?

    // Team management
    var tradesRemaining: Int { max(0, 8 - tradesUsed) }
    @Published var teamValue: Int = 12_000_000
    @Published var bankBalance: Int = 300_000

    func refreshData() {
        Task {
            await MainActor.run {
                isRefreshing = true
                connectionStatus = .connecting
            }

            // Simulate API call
            try? await Task.sleep(nanoseconds: 2_000_000_000)

            await MainActor.run {
                isRefreshing = false
                connectionStatus = .connected
                lastUpdateTime = Date()
                errorMessage = nil

                // Update some sample data
                teamScore = Int.random(in: 1800 ... 2200)
                teamRank = Int.random(in: 1000 ... 15000)
            }
        }
    }

    func simulateError(_ message: String) {
        errorMessage = message
        connectionStatus = .error
    }

    func clearError() {
        errorMessage = nil
        if connectionStatus == .error {
            connectionStatus = .connected
        }
    }
}

// MARK: - Design System Extensions

extension DesignSystem {
    enum IconSize {
        static let small = CGFloat(16)
        static let medium = CGFloat(20)
        static let large = CGFloat(24)
        static let xlarge = CGFloat(32)

        var value: CGFloat {
            switch self {
            case .small: 16
            case .medium: 20
            case .large: 24
            case .xlarge: 32
            }
        }
    }
}

// MARK: - Button Style

struct AFLButtonStyle: ButtonStyle {
    enum Variant {
        case primary
        case secondary
        case tertiary
    }

    let variant: Variant

    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding(.horizontal, DesignSystem.Spacing.m.value)
            .padding(.vertical, DesignSystem.Spacing.s.value)
            .background(backgroundColor(for: variant, isPressed: configuration.isPressed))
            .foregroundColor(foregroundColor(for: variant))
            .cornerRadius(DesignSystem.CornerRadius.medium.value)
            .scaleEffect(configuration.isPressed ? 0.98 : 1.0)
            .animation(.easeInOut(duration: 0.1), value: configuration.isPressed)
    }

    private func backgroundColor(for variant: Variant, isPressed: Bool) -> Color {
        let baseColor: Color = switch variant {
        case .primary: DesignSystem.Colors.primary
        case .secondary: DesignSystem.Colors.surfaceVariant
        case .tertiary: Color.clear
        }

        return isPressed ? baseColor.opacity(0.8) : baseColor
    }

    private func foregroundColor(for variant: Variant) -> Color {
        switch variant {
        case .primary: .white
        case .secondary: DesignSystem.Colors.primary
        case .tertiary: DesignSystem.Colors.primary
        }
    }
}

// MARK: - Tappable Frame Modifier

extension View {
    func tappableFrame(minWidth: CGFloat = 44, minHeight: CGFloat = 44) -> some View {
        frame(minWidth: minWidth, minHeight: minHeight)
            .contentShape(Rectangle())
    }
}
